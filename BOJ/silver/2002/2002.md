## 문제

대한민국을 비롯한 대부분의 나라에서는 터널 내에서의 차선 변경을 법률로 금하고 있다. 조금만 관찰력이 있는 학생이라면 터널 내부에서는 차선이 파선이 아닌 실선으로 되어 있다는 것을 알고 있을 것이다. 이는 차선을 변경할 수 없음을 말하는 것이고, 따라서 터널 내부에서의 추월은 불가능하다.

소문난 명콤비 경찰 대근이와 영식이가 추월하는 차량을 잡기 위해 한 터널에 투입되었다. 대근이는 터널의 입구에, 영식이는 터널의 출구에 각각 잠복하고, 대근이는 차가 터널에 들어가는 순서대로, 영식이는 차가 터널에서 나오는 순서대로 각각 차량 번호를 적어 두었다.

N개의 차량이 지나간 후, 대근이와 영식이는 자신들이 적어 둔 차량 번호의 목록을 보고, 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차들이 몇 대 있다는 것을 알게 되었다. 대근이와 영식이를 도와 이를 구하는 프로그램을 작성해 보자.

## 입력

입력은 총 2N+1개의 줄로 이루어져 있다. 첫 줄에는 차의 대수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 대근이가 적은 차량 번호 목록이 주어지고, N+2째 줄부터 N개의 줄에는 영식이가 적은 차량 번호 목록이 주어진다. 각 차량 번호는 6글자 이상 8글자 이하의 문자열로, 영어 대문자('A'-'Z')와 숫자('0'-'9')로만 이루어져 있다.

같은 차량 번호가 두 번 이상 주어지는 경우는 없다.

## 출력

첫째 줄에 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차가 몇 대인지 출력한다.

## 예제 입력 1 복사

```
4
ZG431SN
ZG5080K
ST123D
ZG206A
ZG206A
ZG431SN
ZG5080K
ST123D

```

## 예제 출력 1 복사

```
1

```

## 예제 입력 2 복사

```
5
ZG508OK
PU305A
RI604B
ZG206A
ZG232ZF
PU305A
ZG232ZF
ZG206A
ZG508OK
RI604B

```

## 예제 출력 2 복사

```
3

```

## 예제 입력 3 복사

```
5
ZG206A
PU234Q
OS945CK
ZG431SN
ZG5962J
ZG5962J
OS945CK
ZG206A
PU234Q
ZG431SN

```

## 예제 출력 3 복사

```
2
```

## 코드

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int main() {
	int N;
	cin >> N;

	unordered_map<string, int> um;
	vector<string> youngsick;

	for (int i = 0; i < N; i++) {
		string str;
		cin >> str;
		um.insert({ str, i });
	}

	for (int i = 0; i < N; i++) {
		string str;
		cin >> str;
		youngsick.push_back(str);
	}

	int count = 0;

	for (int i = 0; i < youngsick.size(); i++) {
		for (int j = i + 1; j < youngsick.size(); j++) {
			if (um[youngsick[i]] > um[youngsick[j]]) {
				count++;
				break;
			}
		}
	}

	cout << count;

}
```

## 문제 풀이

대근이가 적은 차량과 영식이가 적은 차량을 비교하여 추월이 일어난 횟수를 구하는 문제이다. 

먼저 대근이가 적은 터널을 들어가는 차량으로 차량마다 순서를 기록한다. 이를 기록하기 위해 `unorderd_map`을 사용하여 차량`str`과 순서`i`를 기록했다. 

 영식이가 적은 터널을 나오는 차량은 `youngsick`이라는 벡터에 저장하였다. 

터널을 나오는 차량을 처음부터 살펴보며, 자신의 차량 이후에 나오는 차량 중에 자신보다 빨리 진입했던 차량이 있으면 추월을 한 것으로 보았다. 


**map과 unordered_map의 차이**

**map** 

- 구현 방식 : 이진 탐색 트리 또는 레드-블랙 트리로 구현되어 있다.
- 정렬 여부 : map은 키를 정렬된 순서로 유지한다. 요소들이 삽입된 순서와 상관없이, 키의 크기에 따라 정렬된 상태로 저장한다.
- 시간 복잡도 : 삽입, 삭제, 탐색은 O(logN)

**unordered_map** 

- 구현 방식 : 해시 테이블을 사용하여 구현되어 있다.
- 정렬 여부 : 정렬되지 않는다. 키가 삽입된 순서나 특정 순서에 상관없이 저장된다.
- 시간 복잡도 : 탐색, 삽입, 삭제는 평균적으로 O(1)의 시간 복잡도를 가진다. 최악의 경우 해시 충돌이 많이 발생하면 O(N)까지 시간 복잡도가 증가한다.
